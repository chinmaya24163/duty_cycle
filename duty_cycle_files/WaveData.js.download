(function() {
  /*
  Redwood EDA, LLC
  original author: Alex DeFiore
  */
  /*
  WaveData class stores waveform data from a VCD file.

  TODO: Do we squash glitches? This is important for SignalValue methods that operate on transitions.
  */
  var ScopeVariable, SignalValue, Utils, Variable, WaveData,
    indexOf = [].indexOf,
    hasProp = {}.hasOwnProperty;

  [Variable, ScopeVariable, SignalValue, Utils] = [];

  WaveData = (function() {
    var Scope, clkSig, resetSig;

    class WaveData {
      constructor(src, sandSim) {
        this.sandSim = sandSim;
        SignalValue.staticInit(this.TIME_SLOT_WIDTH, this.TRANSITION_FIELDS);
        Variable.staticInit(this.TIME_SLOT_WIDTH, this.TRANSITION_FIELDS);
        this.updateData(src);
      }

      /*
      updates the information contained within the instance of WaveData
      @param {String} src is the source of the new vcd data
      */
      updateData(src) {
        Utils.assert(src);
        this.parseData(src);
        this.clkAndReset();
        this.mapTime();
        this.initSigs();
        this.lookupConditionSignals();
        return this.generateInvalids();
      }

      /*
      Add a signal transition from the vcd.
      */
      addPoint(nickname, cyc, value) {
        if (this.wavesByNickname[nickname]) {
          return this.wavesByNickname[nickname].transitions.push(cyc, value, true);
        }
      }

      /*
      Convert VCD time to cycle
      @param {int} time
      @return {Number} cycle (int or int.5)
      */
      timeToCycle(time) {
        return (time - this.cycleZeroTime) / this.cycleLength;
      }

      /*
      Parses a .vcd file, producing:
        signal info in @signals array and in hierarchial form in @sigHier
        waveform data referenced by @signals[<name>].data and hierarchically via @sigHier
      Top-level VCD hierarchy is modified.
      VCD could have been generated by Makerchip/SandStorm or by other tools (for debug mode)
      VCD from Makerchip/SandStorm contains hierarchy like:
      ```
      TOP   <-- Used to determine that this is a Makerchip/SandStorm-generated waveform.
        makerchip
          ...
          top
            clk
            reset
            DEBUG_SIGS <-- Becomes TLV scope; there must be only one.
              ...
            sv_sig1
            sv_scope1
              etc
      ```
      And this is restructured into:
      ```
      clk
      reset
      TLV (from DEBUG_SIGS)
        ...
      SV (from top for Makerchip/SandStorm or implicit top-level scope otherwise
        ...
      ```

      @param {String} input the input string to parse
      */
      parseData(input) {
        var carrier, currentAlignmentDelta, currentScope, currentTime, currentVcdScope, cycleLengthConfidence, date, debugSigsDepth, debugSigsGtkwave, debugSigsScope, delta, depth, e, fullName, id, inDebugSigs, index, isFromMakerchip, item, j, l, len1, len2, letters, lines, m, mod, next, nickname, nonExistentSignal, oldTime, ref, ref1, rootScope, s, scope, setEnd, svScope, svVars, temp, tlvScope, tlvTopScope, tlvVars, topVars, ts, v, value, vcdScopes, version, w, words;
        //split vcd file into "words"
        // TODO: Process this as a stream.
        lines = input.split("\n");
        lines = (function() {
          var j, len1, results;
          results = [];
          for (j = 0, len1 = lines.length; j < len1; j++) {
            item = lines[j];
            if (item.length > 0) {
              results.push(item);
            }
          }
          return results;
        })();
        w = [];
        for (j = 0, len1 = lines.length; j < len1; j++) {
          l = lines[j];
          w.push(l.trim());
        }
        words = [];
        for (m = 0, len2 = w.length; m < len2; m++) {
          l = w[m];
          words.push(...(l.split(" ")));
        }
        words = (function() {
          var len3, n, results;
          results = [];
          for (n = 0, len3 = words.length; n < len3; n++) {
            item = words[n];
            if (item.trim().length > 0) {
              results.push(item);
            }
          }
          return results;
        })();
        //initialize helper variables
        carrier = [];
        currentTime = -1;
        isFromMakerchip = null; // Boolean, based on existence of TOP scope as the top-level scope.
        rootScope = new ScopeVariable("", null, 0);
        svScope = new ScopeVariable("SV", rootScope, 1);
        tlvTopScope = new ScopeVariable("TLV", rootScope, 1);
        // scope most recently created, initialized to top-level scope.
        currentScope = rootScope;
        ts = "";
        version = "";
        depth = -1; // -1 until we find scope we care to represent.
        setEnd = false;
        inDebugSigs = false; // True while parsing within DEBUG_SIGS*.
        debugSigsGtkwave = false; // When inDebugSigs, true for DEBUG_SIGS_GTKWAVE.
        debugSigsScope = null; // The SV scope of DEBUG_SIGS*.
        debugSigsDepth = -1; // The scope depth of DEBUG_SIGS*.
        // the names of the levels of the current VCD scope, where the outermost is [0].
        vcdScopes = [];
        currentVcdScope = null; // maintained as vcdScope[vcdScope.length - 1]
        currentAlignmentDelta = 0; // Delta for @edgeAlignmentCount for each transition.
        // Incremented for consistent length, decremented for inconsistent.
        cycleLengthConfidence = 0;
        this.numTlvSignals = 0; // A running count of TLV signals.
        this.wavesByNickname = {};
        this.sigHier = new Scope(null, false, "");
        tlvScope = new Scope(this.sigHier, true, "TLV");
        new Scope(this.sigHier, false, "SV");
        svVars = {}; // Variables structure passed on to WaveData.
        topVars = {}; // Top-level vars (clk/reset) merged into vars after all vars are processed.
        tlvVars = {}; // TLV signals merged into vars after all vars are processed.
        // {
        //   <nickname>: {
        //     vars: {Variable1, Variable2},  # Equivalent "variables" that use this nickname
        //                                    # ("sig1 = sig2;"" will result in the same nickname.)
        //     point: [[cycle, value, valid], [cycle, value, valid], ...]
        //   }, ...
        // }
        //loop for header, grabbing date, version, timescale, and variable names in scope
        //collects until finding an $end word, and then processes the statements between $ends
        /*
        Examples of vcd lines (this loop stops before reaching signal data and transitions)
        $var:
          $var wire  1 v clk $end
          results in
          temp = ['wire', '1', 'v', 'clk']
        $date:
          $date Mon Aug  8 09:40:42 2016 $end
        $version:
          $version Generated by VerilatedVcd $end
        $timescale:
          $timescale   1ns $end
        $scope:
          $scope module TOP $end
          $scope module sigs [0] $end
          results in
          temp = ['module', 'TOP']
          temp = ['module', 'sigs', '[0]']
        $upscope:
          $upscope $end
        */
        index = 0;
        scope = this.sigHier.children.SV;
        while (index < words.length && words[index] !== "$dumpvars" && !setEnd) {
          next = words[index];
          index++;
          if (next === "$end" && carrier.length > 0) {
            id = carrier.shift();
            temp = carrier;
            carrier = [];
            switch (id) {
              case "$date":
                date = temp;
                break;
              case "$version":
                version = temp;
                break;
              case "$timescale":
                ts = temp;
                break;
              case "$comment":
                null;
                break;
              case "$var":
                // Include signals that are inside scope as well as top-level "clk" and "reset".
                if (currentScope !== rootScope) {
                  v = Variable._makeVar(this, temp, currentScope.name, currentScope.depth);
                  // Initialize *Vars here so that they have the same order as the trace file.
                  // Order top-level, SV, and TLV signals independently, then merge them
                  // in the desired order.
                  // TODO: Signals should be ordered more explicitly.
                  if (inDebugSigs) {
                    tlvVars[v.fullName] = null;
                    this.numTlvSignals++; // SV
                  } else {
                    svVars[v.fullName] = null;
                    if (currentScope === svScope) {
                      // clk and reset are special.
                      // Add them at top level as well (outside of SV), and set @clkSig/@resetSig for later processing.
                      if (v.notFullName === "clk") {
                        topVars[v.fullName] = null;
                        this.clkSig = v;
                        this.sigHier.sigs.clk = v;
                      }
                      if (v.notFullName === "reset") {
                        topVars[v.fullName] = null;
                        this.resetSig = v;
                        this.sigHier.sigs.reset = v;
                      }
                    }
                  }
                  scope.sigs[v.notFullName] = v;
                  if (!this.wavesByNickname[v.nickname]) {
                    this.wavesByNickname[v.nickname] = {
                      vars: [],
                      transitions: []
                    };
                  }
                  // add v to it
                  this.wavesByNickname[v.nickname].vars.push(v);
                }
                break;
              //delete v.name
              case "$scope":
                currentVcdScope = temp[1];
                // Standardize scopes to use [] for indices.
                // Different waveform viewers use different brackets.
                // Verilator: (), <>, ...
                currentVcdScope = currentVcdScope.replace(/\((\d+)\)$/, "[$1]");
                currentVcdScope = currentVcdScope.replace(/<(\d+)>$/, "[$1]");
                if (inDebugSigs && debugSigsGtkwave) {
                  // To work around Yosys and GTK Wave bugs, DEBUG_SIGS pipeline scopes have been provided
                  // using "P_" prefix, rather than "|".
                  // Map "P_" to "|".
                  if (currentVcdScope.startsWith("P_")) {
                    currentVcdScope = "|" + currentVcdScope.substring(2);
                  }
                }
                vcdScopes.push(currentVcdScope);
                if (isFromMakerchip === null) {
                  // This is the first scope encountered.
                  isFromMakerchip = currentVcdScope === "TOP";
                  if (!isFromMakerchip) {
                    // Enter "SV" scope.
                    depth++;
                    currentScope = svScope;
                  }
                }
                // Rename top-level scopes
                if (currentVcdScope.startsWith("DEBUG_SIGS") && debugSigsScope !== null) {
                  Utils.assert(false, "VCD trace file was generated from multiple \TLV contexts (DEBUG_SIGS scopes presumably generated from SandPiper with --debugSigs argument). This is not currently supported.");
                }
                if ((currentScope === rootScope) && (currentVcdScope === "top")) {
                  currentScope = svScope;
                  depth = 1;
                } else if (currentVcdScope.startsWith("DEBUG_SIGS") && debugSigsScope === null) {
                  // Enter TLV scope and pull it top-level
                  // Record scope so that it can be restored
                  debugSigsScope = currentScope;
                  debugSigsGtkwave = currentVcdScope === "DEBUG_SIGS_GTKWAVE";
                  debugSigsDepth = depth;
                  depth = 1;
                  currentScope = tlvTopScope;
                  tlvScope.svParent = scope; // Need to remember where to exit this scope since it has a modified parent for viewer.
                  scope = tlvScope;
                  inDebugSigs = true;
                } else if (depth >= 0) {
                  depth++;
                  if (temp.length >= 2) {
                    currentScope = new ScopeVariable(currentVcdScope, currentScope, depth, temp.length > 2 ? temp[2] : "");
                  } else {
                    console.log(`VCD file contains malformed $scope line: ${temp}`);
                  }
                  // create and enter new scope
                  s = new Scope(scope, inDebugSigs, currentVcdScope);
                  scope.children[currentVcdScope] = s;
                  scope = s;
                }
                break;
              case "$upscope":
                // Go up a scope level, with appropriate adjustments for top-level hierarchy.
                if (currentScope === tlvTopScope) {
                  currentScope = debugSigsScope;
                  depth = debugSigsDepth;
                  scope = this.sigHier.children.TLV.svParent; // Exit into SV hierarchy context, not top level.
                  inDebugSigs = false;
                } else if (currentScope === svScope) {
                  currentScope = rootScope;
                  depth === -1;
                } else if (currentScope !== rootScope) {
                  // Inside TLV or SV scope.
                  currentScope = currentScope.parent;
                  depth--;
                  scope = scope.parent;
                }
                currentVcdScope = vcdScopes.pop();
                break;
              case "$enddefinitions":
                setEnd = true;
                break;
              default:
                console.log(`unexpected identifier: ${id}\n`);
            }
          } else {
            carrier.push(next);
          }
        }
        
        // Remove TLV if it is empty.
        if (this.sigHier.children.TLV.children.legth <= 0 && this.sigHier.children.TLV.sigs.length <= 0) {
          delete this.sigHier.children.TLV;
        }
        
        // Merge top-level, TLV, and SV sigs in the desired order
        this.signals = {};
        for (fullName in topVars) {
          this.signals[fullName] = topVars[fullName];
        }
        for (fullName in tlvVars) {
          this.signals[fullName] = tlvVars[fullName];
        }
        for (fullName in svVars) {
          this.signals[fullName] = svVars[fullName];
        }
        try {
          // Process signal transitions. These are within #\d+ lines that specify time.
          // The first time should provide all initial values. In some .vcds these are given within
          // $dumpvars/$end, other times not. We simply ignore $dempvars/$end within @start time.
          currentTime = null;
          // Loop over words
          while (index < words.length && (words[index] != null)) {
            next = words[index];
            index++;
            if (next[0] === "#") {
              oldTime = currentTime;
              currentTime = parseInt(next.substring(1));
              if (isNaN(currentTime)) {
                throw new Error(`Time string \"${next}\" is malformed.`);
              }
              if (oldTime === null) {
                this.start = currentTime;
              } else {
                delta = currentTime - oldTime;
                if (delta < 0) {
                  throw new Error(`Time steps backward from ${oldTime} to ${currentTime}.`);
                }
                if (delta > 0) { // do nothing if delta is zero
                  // Set cycleLength
                  // Cycle length agreement builds confidence and mismatches reduce confidence.
                  // If not confident, try the new delta instead.
                  if (this.cycleLength === null) {
                    this.cycleLength = delta * 2;
                  }
                  if (this.cycleLength === delta * 2) {
                    cycleLengthConfidence++;
                  } else {
                    cycleLengthConfidence--;
                    if (cycleLengthConfidence <= 0) {
                      this.cycleLength = delta * 2;
                      cycleLengthConfidence = 1;
                    }
                    this.cycleLengthConsistent = false;
                  }
                  mod = (currentTime - this.start) % this.cycleLength;
                  // Is this aligned with even or odd phase (only matters if @cycleLength > 0)
                  currentAlignmentDelta = mod === 0 ? 1 : mod === delta ? -1 : 0;
                }
              }
            } else if (next[0] === "$") {
              if (next === "$comment") {
                while (next && (next !== "$end")) {
                  next = words[index];
                  index++;
                }
              } else if ((next !== "$dumpvars") && ((currentTime !== this.start) || (next !== "$end"))) {
                throw new Error(`Found unexpected word \"${next}\".`);
              }
            } else {
              // Signal value.

              // We've seen traces where values are given in $dumpvars prior to a time stamp, and this is to be treated as time zero.
              if (currentTime === null) {
                this.start = currentTime = 0;
                console.log("Warning: VCD parsing found signal values prior to a timestamp. Assuming time=0.");
              }
              letters = next.split("");
              nickname = "";
              value = "";
              if ((ref = parseInt(letters[0]), indexOf.call([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], ref) >= 0) || (letters[0] === "x") || (letters[0] === "z")) { // TODO: improve this
                // boolean format
                nickname = next.substring(1);
                value = letters[0];
              } else {
                // vector format
                nickname = words[index];
                index++;
                value = next.substring(1);
              }
              this.addPoint(nickname, currentTime, value);
              this.edgeAlignmentCount += currentAlignmentDelta;
            }
          }
          
            // Skip extraneous words.
          while (index < words.length && ((ref1 = words[index]) !== "$dumpvars" && ref1 !== "#0")) { // "#0" assumes Makerchip sim, not debug mode.
            index++;
          }
        } catch (error) {
          e = error;
          Utils.assert(false, `Error parsing VCD file: ${e.message}`);
        }
        // Create a signal to use for any that are not found.
        nonExistentSignal = new Variable(this, 0, "", "", "", "wire", "[-1:0]", 0);
        nonExistentSignal.missing = true;
        this.wavesByNickname[""] = {
          vars: [nonExistentSignal],
          transitions: [this.start, "", false]
        };
        this.lastTime = currentTime;
        this.timescale = {
          number: "",
          unit: ""
        };
        //process timescale
        if (ts.length > 1) {
          this.timescale.number = parseInt(ts[0], 10);
          return this.timescale.unit = ts[1];
        } else {
          index = 1;
          ts = ts[0].trim();
          while (!isNaN(ts.substring(0, index)) && index <= ts.length) {
            index++;
          }
          this.timescale.number = parseInt(ts.substring(0, index), 10);
          return this.timescale.unit = ts.substring(index - 1);
        }
      }

      /*
      Analyze clk and reset signals to determine the cycletime and time zero of the trace.
      For Makerchip simulations (not "debug mode", where traces are generated externally),
      verify that these match expectations.
      The cycle time is determined by the first clock cycle.
      Time zero is the end of reset.
      */
      clkAndReset() {
        var cTrans, len, msg, ok, rTrans, vals;
        // Examine clk.
        if (this.clkSig) {
          cTrans = this.wavesByNickname[this.clkSig.nickname].transitions;
          if (cTrans.length < 6) {
            console.log("Warning: Not enough clk cycles in waveform to determine clock period.");
          } else {
            vals = cTrans[1] + cTrans[4];
            this.cycleLength = cTrans[6] - cTrans[0];
            if (this.sandSim) {
              ok = vals === "10" && (cTrans[0] === this.start) && (this.cycleLength === 2);
              Utils.assert(ok, "Clk signal does not exhibit the expected behavior.");
            } else {
              ok = (vals === "01") || (vals === "10");
            }
          }
        }
        if (!this.cycleLength) {
          this.cycleLength = 2;
          this.cycleLengthConsistent = false;
        }
        if (!this.clkSig) {
          if (this.sandSim) {
            Utils.assert(false, `Trace is missing 'clk' signal. Using cycle time of ${this.cycleLength}.`);
          } else {
            if (!this.cycleLengthConsistent) {
              Utils.assert(false, `No 'clk' signal and couldn't reliably infer cycle time from trace. Using best guess of ${this.cycleLength}.`);
            } else {
              console.log(`No 'clk' signal found. Inferred clock cycle time of ${this.cycleLength} from trace's timesteps.`);
            }
          }
        }
        
        // Examine reset, and set @cycleZeroTime
        if (this.sandSim) {
          Utils.assert(this.resetSig, "Trace is missing reset signal.");
        }
        
        // If a reset signal is found and has expected behavior, set time zero to the end of reset.
        // Otherwise, set time zero heuristically at @start or @start + 1 phase.
        this.cycleZeroTime = this.start;
        if (this.resetSig) {
          rTrans = this.wavesByNickname[this.resetSig.nickname].transitions;
          // Expected behavior is 1, then 0 and nothing more, with an optional initial value of 0.
          len = rTrans.length;
          if (((len === 6) || (len === 9)) && (rTrans[0] === this.start) && (rTrans[len - 5] === "1") && (rTrans[len - 2] === "0")) {
            // Reset signal exhibits expected behavior.
            return this.cycleZeroTime = rTrans[len - 3];
          }
        } else {
          // Determine time zero alignment based on @edgeAlignmentCount.
          if (this.edgeAlignmentCount < 0) {
            this.cycleZeroTime += this.cycleLength / 2;
          }
          // Report missing reset.
          msg = `Trace is missing 'reset' signal. Cycle zero edge placed at simulation time ${this.cycleZeroTime}.`;
          if (this.sandSim) {
            return Utils.assert(false, `Error: ${msg}`);
          } else {
            return console.log(`Warning: ${msg}`);
          }
        }
      }

      /*
      Adjust the times in the trace (transitions) such that time zero is as desired and the
      clock period is 1 time unit.
      TODO: Need to support non-zero @start time for external (debug mode) vcds.
      */
      mapTime() {
        var i, nickname, ref, t, wave;
        ref = this.wavesByNickname;
        for (nickname in ref) {
          wave = ref[nickname];
          // Map time.
          t = wave.transitions;
          i = 0;
          while (i < t.length) {
            t[i] = this.timeToCycle(t[i]);
            i += 3;
          }
        }
        this.startCycle = this.timeToCycle(this.start);
        this.endCycle = this.timeToCycle(this.lastTime);
        return this.lastTime += this.cycleLength / 2; // Add a phase to make the final transitions visible.
      }

      /*
      Initialize @signals with transitions and anchor points indexing into transitions at regular intervals.
      For signals with conditions, do not initialize anchors. (See generateInvalids().)
      */
      initSigs() {
        var anchors, j, k, len1, nickname, ref, ref1, v, wave;
        ref = this.wavesByNickname;
        for (nickname in ref) {
          wave = ref[nickname];
          // Create an object for each variable with this nickname.
          anchors = null;
          ref1 = wave.vars;
          for (j = 0, len1 = ref1.length; j < len1; j++) {
            v = ref1[j];
            // Compute anchors, though it will be recomputed if conditions are applied to the transitions,
            // so we can avoid computing anchors until there is a need.
            if (anchors === null && v.conditions.length === 0) {
              anchors = this.computeAnchors(wave.transitions);
            }
            v._setTransitions(wave.transitions, anchors);
            if (this.signals[v.fullName] != null) {
              console.log(`ERROR: Multiple signals with the name ${v.fullName}. Bit merging not supported.`);
            } else {
              // TODO: It seems VCS, QuestaSim, ModelSim, and Riviera-PRO can produce signals like:
              //          $var wire 1 K a1 [7] $end
              //          $var wire 1 L a1 [6] $end
              //       that should be combined into a vector.
              this.signals[v.fullName] = v;
            }
          }
        }
        this.names = (function() {
          var ref2, results;
          ref2 = this.signals;
          results = [];
          for (k in ref2) {
            if (!hasProp.call(ref2, k)) continue;
            v = ref2[k];
            results.push(v.fullName);
          }
          return results;
        }).call(this);
        return this.numSignals = this.names.length;
      }

      /*
      Determine anchors according to transitions.
      @param {Array} transitions the transitions array (see {Variable})
      @return {Array} anchors (see {Variable})
      */
      computeAnchors(transitions) {
        var anchorPt, anchors, cyc, done, i, len, trans;
        Utils.assert(transitions[0] === this.startCycle, `Expected signal waveform to start at cycle ${this.startCycle}.`);
        // Number of transitions in transitions array.
        len = Math.round(transitions.length / this.TRANSITION_FIELDS); // Ensure no rounding error.
        // Iterate.
        anchors = [];
        anchorPt = 0;
        trans = 0;
        done = false;
        while (!done) {
          // Next transition.
          i = trans * this.TRANSITION_FIELDS;
          if (trans < len) {
            cyc = transitions[i];
          } else {
            done = 1;
            // Pseudo-transition after last transition of trace to provide valid anchor for every cycle within trace.
            cyc = this.endCycle + 1;
          }
          while (cyc > this.anchorIndexToCycle(anchorPt)) {
            anchors[anchorPt] = i - this.TRANSITION_FIELDS;
            anchorPt++;
          }
          trans++;
        }
        return anchors;
      }

      /*
      Translate an anchor index to its cycle.
      @param {int} i
      @return {Number} the phase-granular cycle number
      */
      anchorIndexToCycle(i) {
        return i * this.TIME_SLOT_WIDTH + this.startCycle;
      }

      /*
      returns the stored timescale
      @return {Object} timescale
      */
      getTimescale() {
        return this.timescale;
      }

      /*
      returns the stored start cycle
      @return {Number} the start cycle
      */
      getStartCycle() {
        return this.startCycle;
      }

      /*
      returns the stored end cycle
      @return {Number} the end cycle ((phase-granular) cycle of last transition in trace)
      */
      getEndCycle() {
        return this.endCycle;
      }

      /*
      @returns {Number} the end cycle number to view in the waveform viewer.
      */
      getEndViewerCycle() {
        return this.endCycle + 0.5;
      }

      /*
      returns the list of signals which also contains their data, name, scope, type, width
      @return {Object} the signals
      */
      getSignals() {
        return this.signals;
      }

      /*
      returns how many signals are stored in this WaveData
      @return {Number} the number of signals
      */
      getNumSignals() {
        return this.numSignals;
      }

      /*
      returns a list of the names of every signal stored in this WaveData
      @return {Array<String>} all of the signal names
      */
      getSignalNames() {
        return this.names;
      }

      /*
      returns the scope of the signal by the given name
      @param {String} name the name of the desired signal
      @return {String} the scope name
      */
      getScopeByName(name) {
        if (this.signals[name] != null) {
          return this.signals[name].scope;
        }
        return "";
      }

      /*
      returns the value of the signal by the given name, at the given cycle
      @param {String} name the name of the desired signal
      @param {Number} cyc the cycle of the desired value
      @return {SignalValue} the corresponding {SignalValue} or a SignalValue
                  for a non-existent signal if not found.
      */
      getSignalValueAtCycleByName(name, cyc) {
        var sig;
        sig = this.getSignalByName(name);
        return new SignalValue(sig, cyc);
      }

      /*
      returns a signal with the given name
      @param {String} name the name of the desired signal
      @return {Object} the signal
      */
      getSignalByName(name) {
        var ret;
        ret = null;
        if (this.signals[name] != null) {
          ret = this.signals[name];
        } else {

        }
        // TODO: This can be removed once we transition to NonExistentSignalError, but it can be helpful in the meantime.
        // console.log("Info: Signal not found: #{name}")
        return ret;
      }

      /*
      Transforms @signals.conditions from strings to {Variable}s.
      Condition is null for any signals that are not found.
      */
      lookupConditionSignals() {
        var condSig, condition, conditions, j, len1, name, newCond, ref, results, sig;
        ref = this.signals;
        results = [];
        for (name in ref) {
          if (!hasProp.call(ref, name)) continue;
          sig = ref[name];
          newCond = [];
          conditions = sig.conditions;
          for (j = 0, len1 = conditions.length; j < len1; j++) {
            condition = conditions[j];
            condSig = this.getSignalByName(condition);
            if (condSig == null) {
              console.log(`Can't find condition signal: ${condition} for signal ${name}`);
            }
            newCond.push(condSig);
          }
          results.push(sig.conditions = newCond);
        }
        return results;
      }

      /*
      For each signal that has conditions, generate a new waveform for the signal that incorporates
      invalidity, and associate it with the signal.
      Conditions outside the trace window result in undefined validity values.
      Note that conditions that are themselves invalid should be shadowed by another invalid condition in proper
        TLV code. We do not check this here. (Doing so would require outer-scope signals to be processed before inners.)
      */
      generateInvalids() {
        var cond, condCycle, condSig, condValid, conditions, cyc, j, len1, len2, len3, m, n, name, newTrans, nextCycle, origTrans, origTransCycle, prevValid, prevValue, ref, ref1, results, sig, transIndex, valid;
        ref = this.signals;
        results = [];
        for (name in ref) {
          if (!hasProp.call(ref, name)) continue;
          sig = ref[name];
          origTrans = sig.transitions;
          if (sig.conditions.length > 0) {
            // This signal has conditions; generate a new waveform that reflects them.
            newTrans = []; // The new waveform transitions.
            
            // Starting at first transition, determine next transition cycle (of signal or its conditions)
            // and determine new transition validity and value. If the value changes, create a transition
            // Initial state is garbage value to force first transition.

            // At loop top, the index into the cycle field of origTrans
            // defining the value before cyc. Initially, the
            // non-existent transition before the first.
            transIndex = -this.TRANSITION_FIELDS;
            // At loop top, origTrans[transIndex].
            cyc = void 0;
            // At loop top, the last signal value pushed into newTrans. Initially null to force
            // a first transition.
            prevValue = null;
            // At loop top, the last signal validity pushed into newTrans.
            prevValid = true;
            // For each condition {signal, transIndex, offset}, where:
            //   trans: the condition signal's transitions
            //   transIndex: at loop top, the index into the cycle field of the condition
            //               signal's transitions array, defining the value of the condition
            //               signal before cyc.
            //   offset: the non-negative cycle offset of the condition signal relative to 'sig'.
            conditions = [];
            ref1 = sig.conditions;
            for (j = 0, len1 = ref1.length; j < len1; j++) {
              condSig = ref1[j];
              if (condSig !== null) {
                conditions.push({
                  trans: condSig.transitions,
                  transIndex: -this.TRANSITION_FIELDS, // Non-existent transition before first.
                  offset: sig.cycle - condSig.cycle,
                  nextCycle: null // The next transition cycle with offset (used within loop only)
                });
              }
            }
            while (true) {
              // Find the next transition among signal and its conditions.
              nextCycle = origTransCycle = origTrans[transIndex + this.TRANSITION_FIELDS];
              for (m = 0, len2 = conditions.length; m < len2; m++) {
                cond = conditions[m];
                condCycle = cond.trans[cond.transIndex + this.TRANSITION_FIELDS];
                if (typeof condCycle !== "undefined") {
                  cond.nextCycle = cyc = condCycle + cond.offset;
                  if ((typeof nextCycle === "undefined") || (cyc < nextCycle)) {
                    nextCycle = cyc;
                  }
                }
              }
              if (typeof nextCycle === "undefined" || nextCycle > this.endCycle) { // No more transitions to process.
                break;
              }
              // Determine validity of next value, and update indexes to reflect nextCycle.
              if (origTransCycle === nextCycle) {
                transIndex += this.TRANSITION_FIELDS;
              }
              valid = true;
              for (n = 0, len3 = conditions.length; n < len3; n++) {
                cond = conditions[n];
                if (cond.nextCycle === nextCycle) {
                  cond.transIndex += this.TRANSITION_FIELDS;
                }
                condValid = cond.trans[cond.transIndex + 1];
                // condValid pulls valid to the right to its level, where levels are: true, undefined, false.
                if (valid !== false) {
                  if (condValid === "0") {
                    valid = false;
                  } else {
                    if (typeof condValid === "undefined") {
                      valid = void 0;
                    }
                  }
                }
              }
              // If value or valid changed, update previous values and push transition.
              if ((origTrans[transIndex + 1] !== prevValue) || (valid !== prevValid)) {
                // Value or valid changed. Push new transition.
                prevValue = origTrans[transIndex + 1];
                prevValid = valid;
                newTrans.push(nextCycle, prevValue, prevValid);
              }
            }
            results.push(sig._setTransitions(newTrans, this.computeAnchors(newTrans)));
          } else {
            results.push(void 0);
          }
        }
        return results;
      }

    };

    // @property {Number} the granularity of anchor data (cycles per anchor)
    WaveData.prototype.TIME_SLOT_WIDTH = 10;

    // @property {int} The number of items in transitions array per transition.
    WaveData.prototype.TRANSITION_FIELDS = 3;

    // @property {Object} timescale stores the timescale property (ignored/unused)
    WaveData.prototype.timescale = null;

    // @property {Object<Variable>} All {Variable}s indexed by full signal name.
    WaveData.prototype.signals = null;

    // @property {WaveData.Scope} the signal hierarchy of the trace
    WaveData.prototype.sigHier = null;

    // @property {int} the time of one phase beyond the last transition in the trace.
    WaveData.prototype.lastTime = -1;

    // @property {Number} the cycle (or cycle.5) of the last transition in the trace.
    //                    (one phase before lastTime)
    WaveData.prototype.endCycle = -1;

    // @property {int} start the start time value in waves (usually 0)
    WaveData.prototype.start = 2e308;

    // @property {Number} the first cycle (or cycle.5) in the trace.
    WaveData.prototype.startCycle = 2e308;

    // @property {Array<String>} names the list of signal names
    WaveData.prototype.names = null;

    // @property {int} numSignals the number of signals
    WaveData.prototype.numSignals = 0;

    // @property {int} numTlvSignals the number of TLV signals
    WaveData.prototype.numTlvSignals = 0;

    // @property {boolean} this is a simulation performed by us, so it should have certain
    //                     properties we can rely on
    WaveData.prototype.sandSim = null;

    
    // These reflect clk and reset inputs and/or timestamps in trace.
    // @property {int, null} the length of a cycle in time units; null until trace is analyzed;
    //                -negative after analysis if trace has inconsistent steps and no clk.
    WaveData.prototype.cycleLength = null;

    // @property {Boolean} the cycle length is consistent throughout the trace.
    WaveData.prototype.cycleLengthConsistent = true;

    // @property {Number} the time of cycle zero (reset assertion edge or first cycle-edge in waveform)
    WaveData.prototype.cycleZeroTime = null;

    
    // @property {Object} waves stored and indexed by nickname
    //   { <nickname>: {vars: Variables with this nickname,
    //                  transitions: [<time>, <value-str>, <valid>]
    //     ...}
    WaveData.prototype.wavesByNickname = null;

    // @property {Number} used to determine whether to align cycle to even or odd edges.
    //             +1 for transitions that align to time delta * 2 period;
    //             -1 for transitions that align to time delta * 2 + 1
    //             Initialize with a bias toward natural alignment.
    WaveData.prototype.edgeAlignmentCount = 10;

    // @property {Variable, null} The clk signal or null.
    clkSig = null;

    // @property {Variable, null} The reset signal or null.
    resetSig = null;

    /*
    A level of hierarchy in trace (within @sigHier).
    TODO: Huh, I added this without realizing we already had ScopeVariable. I think this should superceed ScopeVariable.
    */
    Scope = class Scope {
      constructor(parent, isTlv, name1) {
        this.parent = parent;
        this.isTlv = isTlv;
        this.name = name1;
        this.sigs = {};
        this.children = {};
        // Add to parent
        if (this.parent) {
          if (this.parent.children[this.name] != null) {
            console.log(`Error: Ignoring duplicate scope ${this.parent.children[this.name].getFullScope()} in trace file.`);
          } else {
            this.parent.children[this.name] = this;
          }
        }
      }

      addSig(sig) {
        if (this.sigs[sig.notFullName] != null) {
          return console.log(`Error: Ignoring duplicate signal ${sig.fullName}.`);
        } else {
          return this.sigs[sig.notFullName] = sig;
        }
      }

      
        // Note, this will fail from @sigHier.
      // @return {String} full path to this scope, starting with "TLV" or "SV.".
      getFullScope() {
        if (this.parent) {
          return (this.parent.name ? this.parent.getFullScope() + (this.isTlv ? "" : ".") : "") + this.name;
        } else {
          return "";
        }
      }

    };

    return WaveData;

  }).call(this);

  define(function(require, exports, module) {
    var $;
    $ = require("jquery");
    Utils = require("Utils");
    Variable = require("VCD/Variable");
    ScopeVariable = require("VCD/ScopeVariable");
    SignalValue = require("VCD/SignalValue");
    $.extend(WaveData.prototype, module.config());
    return WaveData;
  });

}).call(this);
